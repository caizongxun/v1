#!/usr/bin/env python3\n\"\"\"ZigZag ML Predictor - With TradingView ZigZag Logic\"\"\"\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import classification_report, confusion_matrix, accuracy_score\nfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier\nfrom sklearn.neural_network import MLPClassifier\nimport yfinance as yf\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# ============================================================================\n# ZIGZAG 標籤生成 - 基於 TradingView 官方邏輯\n# ============================================================================\n\ndef generate_zigzag_labels_tradingview(df, depth=12, deviation=5.0, backstep=2):\n    \"\"\"\n    生成 ZigZag 標籤，完全基於 TradingView 官方指標邏輯\n    \n    參數:\n    - depth: 回看多少根K線找極值 (12)\n    - deviation: 突破閾值百分比 (5.0%)\n    - backstep: 往回走多少根 (2)\n    \n    邏輯:\n    1. 追蹤當前方向 (上升/下降)\n    2. 上升時尋找更高的高點 (HH) 或被打破轉向 (HL)\n    3. 下降時尋找更低的低點 (LL) 或被打破轉向 (LH)\n    4. 當方向改變時記錄轉折點\n    \n    返回:\n    - labels: [0, 1, 2, 3, 4, ...] 每根K線的標籤\n      0=HH, 1=HL, 2=LH, 3=LL, 4=No Pattern\n    - extrema: 所有極值點列表 (用於驗證)\n    \"\"\"\n    \n    n = len(df)\n    labels = np.full(n, 4, dtype=int)  # 初始化為 \"No Pattern\"\n    \n    extrema = []  # 存儲所有極值點\n    \n    # 初始化\n    last_high_idx = 0\n    last_high_price = -np.inf\n    last_low_idx = 0\n    last_low_price = np.inf\n    \n    # 確定初始方向\n    init_window = df.iloc[0:min(depth+1, n)]\n    if len(init_window) > 1:\n        if init_window['close'].iloc[-1] > init_window['close'].iloc[0]:\n            current_direction = 'up'  # 1\n            last_low_price = init_window['low'].min()\n            last_low_idx = init_window['low'].idxmin()\n        else:\n            current_direction = 'down'  # 0\n            last_high_price = init_window['high'].max()\n            last_high_idx = init_window['high'].idxmax()\n    else:\n        current_direction = 'up'\n    \n    # 主循環\n    for i in range(depth, n):\n        # 取最近 depth 根K線\n        window = df.iloc[i-depth:i+1]\n        local_high = window['high'].max()\n        local_high_idx = window['high'].idxmax()\n        local_low = window['low'].min()\n        local_low_idx = window['low'].idxmin()\n        \n        dev_threshold_high = last_high_price * (1 + deviation / 100.0)\n        dev_threshold_low = last_low_price * (1 - deviation / 100.0)\n        \n        # ============================================================\n        # 上升方向: 尋找更高的高點，或被低點打破轉向下降\n        # ============================================================\n        if current_direction == 'up':\n            # 1. 檢查是否有更高的高點\n            if local_high > dev_threshold_high:\n                # 更新高點 → 標記為 HH (Higher High)\n                last_high_price = local_high\n                last_high_idx = local_high_idx\n                extrema.append({\n                    'idx': local_high_idx,\n                    'bar': i,\n                    'price': local_high,\n                    'type': 'high',\n                    'label': 'HH'\n                })\n                labels[local_high_idx] = 0  # HH\n            \n            # 2. 檢查是否被低點打破 → 轉向下降\n            if local_low < dev_threshold_low:\n                # 極值點轉折 → 標記為 LH (Low to High → 轉為下降)\n                current_direction = 'down'\n                last_low_price = local_low\n                last_low_idx = local_low_idx\n                extrema.append({\n                    'idx': local_low_idx,\n                    'bar': i,\n                    'price': local_low,\n                    'type': 'low',\n                    'label': 'LH'\n                })\n                labels[local_low_idx] = 2  # LH\n        \n        # ============================================================\n        # 下降方向: 尋找更低的低點，或被高點打破轉向上升\n        # ============================================================\n        elif current_direction == 'down':\n            # 1. 檢查是否有更低的低點\n            if local_low < dev_threshold_low:\n                # 更新低點 → 標記為 LL (Lower Low)\n                last_low_price = local_low\n                last_low_idx = local_low_idx\n                extrema.append({\n                    'idx': local_low_idx,\n                    'bar': i,\n                    'price': local_low,\n                    'type': 'low',\n                    'label': 'LL'\n                })\n                labels[local_low_idx] = 3  # LL\n            \n            # 2. 檢查是否被高點打破 → 轉向上升\n            if local_high > dev_threshold_high:\n                # 極值點轉折 → 標記為 HL (High to Low → 轉為上升)\n                current_direction = 'up'\n                last_high_price = local_high\n                last_high_idx = local_high_idx\n                extrema.append({\n                    'idx': local_high_idx,\n                    'bar': i,\n                    'price': local_high,\n                    'type': 'high',\n                    'label': 'HL'\n                })\n                labels[local_high_idx] = 1  # HL\n    \n    return labels, extrema\n\n\n# ============================================================================\n# 特徵工程\n# ============================================================================\n\nFEATURE_NAMES = [\n    'Mean_Return',           # f1\n    'Volatility',            # f2\n    'Price_Range',           # f3\n    'Period_Return',         # f4\n    'Volume_Ratio',          # f5\n    'HL_Ratio_Std',          # f6\n    'High_Relative',         # f7\n    'Low_Relative',          # f8\n    'Skewness',              # f9\n    'Kurtosis',              # f10\n    'Up_Count_Ratio',        # f11\n    'Relative_Position',     # f12\n    'Recent_Mean_Return',    # f13\n    'Recent_Volatility',     # f14\n    'Recent_Up_Bars',        # f15\n    'High_Break',            # f16\n    'Low_Break',             # f17\n    'Volume_Trend',          # f18\n    'ATR_Ratio',             # f19\n    'Close_Position',        # f20\n]\n\nLABEL_NAMES = ['HH', 'HL', 'LH', 'LL', 'No Pattern']\nLABEL_DESC = {\n    0: 'HH - Higher High (Uptrend Continue)',\n    1: 'HL - Higher Low (Uptrend Correction)',\n    2: 'LH - Lower High (Downtrend Start)',\n    3: 'LL - Lower Low (Downtrend Continue)',\n    4: 'No Pattern (Other)'\n}\n\nprint(\"=\"*80)\nprint(\"ZigZag ML Predictor - TradingView Logic\")\nprint(\"=\"*80)\n\n# ============================================================================\n# STEP 1: 取得數據\n# ============================================================================\nprint(\"\\n[1/8] Fetching market data...\")\ntry:\n    df = yf.download('BTC-USD', period='2y', interval='1h', progress=False)\n    if isinstance(df.columns, pd.MultiIndex):\n        df.columns = df.columns.get_level_values(0)\n    df = df.reset_index()\n    df.columns = [c.lower().strip() for c in df.columns]\n    print(f\"  OK Loaded {len(df):,} candles\")\nexcept Exception as e:\n    print(f\"  Using synthetic data...\")\n    np.random.seed(42)\n    n = 2000\n    dates = pd.date_range(end=pd.Timestamp.now(), periods=n, freq='1H')\n    close = 40000 * np.exp(np.cumsum(np.random.normal(0.0001, 0.005, n)))\n    df = pd.DataFrame({\n        'datetime': dates,\n        'open': close + np.random.normal(0, close * 0.002, n),\n        'high': close + np.abs(np.random.normal(0, close * 0.003, n)),\n        'low': close - np.abs(np.random.normal(0, close * 0.003, n)),\n        'close': close,\n        'volume': np.random.uniform(100000, 500000, n)\n    })\n\n# ============================================================================\n# STEP 2: 特徵工程\n# ============================================================================\nprint(\"\\n[2/8] Engineering features...\")\nfeatures_list = []\n\nfor i in range(30, len(df) - 5):\n    try:\n        window = df.iloc[i-30:i+1]\n        returns = window['close'].pct_change().dropna().values\n        \n        # Basic Statistics\n        f1 = np.mean(returns) if len(returns) > 0 else 0\n        f2 = np.std(returns) if len(returns) > 1 else 0\n        \n        # Price Action\n        f3 = (window['high'].max() - window['low'].min()) / window['close'].mean()\n        f4 = (window['close'].iloc[-1] - window['close'].iloc[0]) / window['close'].iloc[0]\n        f5 = window['volume'].iloc[-1] / window['volume'].mean() if window['volume'].mean() > 0 else 1\n        \n        # High-Low Analysis\n        f6 = np.log(window['high'] / window['low']).std()\n        f7 = window['high'].iloc[-1] / window['high'].mean() - 1\n        f8 = window['low'].iloc[-1] / window['low'].mean() - 1\n        \n        # Distribution\n        f9 = pd.Series(returns).skew() if len(returns) > 2 else 0\n        f10 = pd.Series(returns).kurtosis() if len(returns) > 3 else 0\n        \n        # Directional\n        up_count = sum(1 for j in range(1, len(window)) if window['close'].iloc[j] > window['close'].iloc[j-1])\n        f11 = up_count / (len(window) - 1) if len(window) > 1 else 0.5\n        highest = window['high'].max()\n        lowest = window['low'].min()\n        f12 = (window['close'].iloc[-1] - lowest) / (highest - lowest) if highest > lowest else 0.5\n        \n        # Recent Momentum\n        recent_returns = window['close'].iloc[-5:].pct_change().dropna()\n        f13 = np.mean(recent_returns) if len(recent_returns) > 0 else 0\n        f14 = np.std(recent_returns) if len(recent_returns) > 1 else 0\n        up_bars = sum(1 for j in range(1, min(6, len(window))) if window['close'].iloc[-j] > window['close'].iloc[-j-1])\n        f15 = up_bars / 5\n        \n        # Support/Resistance\n        recent_window = window.iloc[-10:]\n        recent_high = recent_window['high'].max()\n        recent_low = recent_window['low'].min()\n        f16 = 1 if window['high'].iloc[-1] > recent_high else 0\n        f17 = 1 if window['low'].iloc[-1] < recent_low else 0\n        \n        # Volume\n        vol_recent = window['volume'].iloc[-5:].mean()\n        vol_past = window['volume'].iloc[-20:-5].mean()\n        f18 = vol_recent / vol_past if vol_past > 0 else 1\n        \n        # Volatility\n        tr_list = []\n        for j in range(1, len(window)):\n            tr = max(\n                window['high'].iloc[j] - window['low'].iloc[j],\n                abs(window['high'].iloc[j] - window['close'].iloc[j-1]),\n                abs(window['low'].iloc[j] - window['close'].iloc[j-1])\n            )\n            tr_list.append(tr)\n        f19 = np.mean(tr_list) / window['close'].iloc[-1] if len(tr_list) > 0 else 0\n        f20 = (window['close'].iloc[-1] - window['open'].iloc[-1]) / abs(window['high'].iloc[-1] - window['low'].iloc[-1]) if abs(window['high'].iloc[-1] - window['low'].iloc[-1]) > 0 else 0\n        \n        fv = [f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20]\n        fv = [0 if (np.isnan(x) or np.isinf(x)) else np.clip(x, -100, 100) for x in fv]\n        features_list.append(fv)\n    except Exception as e:\n        features_list.append([0]*len(FEATURE_NAMES))\n\nX = np.array(features_list)\nX_df = pd.DataFrame(X, columns=FEATURE_NAMES)\nprint(f\"  OK {X.shape[0]:,} samples x {X.shape[1]} features\")\n\n# ============================================================================\n# STEP 3: ZigZag 標籤 - 正確邏輯\n# ============================================================================\nprint(\"\\n[3/8] Creating ZigZag labels (TradingView Logic)...\")\ndf_analysis = df.iloc[30:len(df)-5].reset_index(drop=True)  # 對齊特徵長度\n\nlabels, extrema = generate_zigzag_labels_tradingview(\n    df_analysis,\n    depth=12,\n    deviation=5.0,\n    backstep=2\n)\n\ny = labels\nprint(f\"  OK {len(y):,} labels from {len(extrema)} extrema points\")\nprint(f\"\\n  Label Distribution:\")\nlabel_dist = pd.Series(y).value_counts().sort_index()\nfor i in range(5):\n    count = (y == i).sum()\n    pct = 100 * count / len(y) if len(y) > 0 else 0\n    print(f\"    {i}. {LABEL_DESC[i]:40s}: {count:6d} ({pct:5.1f}%)\")\n\nmin_len = min(len(X), len(y))\nX = X[:min_len]\ny = y[:min_len]\nX_df = X_df[:min_len]\n\nprint(f\"\\n  Extrema Points (First 10):\")\nfor i, ext in enumerate(extrema[:10]):\n    print(f\"    {i+1}. Bar {ext['bar']:5d} | Label: {ext['label']:2s} | Price: {ext['price']:.2f}\")\n\n# ============================================================================\n# STEP 4: 數據分割\n# ============================================================================\nprint(\"\\n[4/8] Preparing data...\")\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\n\ntotal_samples = len(X_scaled)\ntest_size = 0.20\nval_size = 0.15\ntrain_size = 0.65\n\ntest_start = int(total_samples * (1 - test_size))\nval_start = int(test_start * (1 - val_size / (1 - test_size)))\n\nX_train = X_scaled[:val_start]\ny_train = y[:val_start]\nX_val = X_scaled[val_start:test_start]\ny_val = y[val_start:test_start]\nX_test = X_scaled[test_start:]\ny_test = y[test_start:]\n\nprint(f\"  OK Data split:\")\nprint(f\"    Training:   {X_train.shape[0]:,} samples ({100*X_train.shape[0]/total_samples:.1f}%)\")\nprint(f\"    Validation: {X_val.shape[0]:,} samples ({100*X_val.shape[0]/total_samples:.1f}%)\")\nprint(f\"    Testing:    {X_test.shape[0]:,} samples ({100*X_test.shape[0]/total_samples:.1f}%)\")\n\n# ============================================================================\n# STEP 5: 模型訓練\n# ============================================================================\nprint(\"\\n[5/8] Training ensemble models...\")\n\nprint(\"  Random Forest...\", end='', flush=True)\nrf = RandomForestClassifier(\n    n_estimators=300,\n    max_depth=15,\n    min_samples_split=5,\n    min_samples_leaf=3,\n    max_features='sqrt',\n    class_weight='balanced_subsample',\n    random_state=42,\n    n_jobs=-1\n)\nrf.fit(X_train, y_train)\nrf_val_score = rf.score(X_val, y_val)\nrf_train_score = rf.score(X_train, y_train)\nprint(f\" OK Train: {rf_train_score:.2%}, Val: {rf_val_score:.2%}\")\n\nprint(\"  Gradient Boosting...\", end='', flush=True)\ngb = GradientBoostingClassifier(\n    n_estimators=200,\n    learning_rate=0.05,\n    max_depth=7,\n    min_samples_split=5,\n    min_samples_leaf=3,\n    subsample=0.8,\n    random_state=42\n)\ngb.fit(X_train, y_train)\ngb_val_score = gb.score(X_val, y_val)\ngb_train_score = gb.score(X_train, y_train)\nprint(f\" OK Train: {gb_train_score:.2%}, Val: {gb_val_score:.2%}\")\n\nprint(\"  Neural Network...\", end='', flush=True)\nnn = MLPClassifier(\n    hidden_layer_sizes=(256, 128, 64),\n    learning_rate_init=0.001,\n    max_iter=500,\n    batch_size=32,\n    alpha=0.001,\n    early_stopping=True,\n    validation_fraction=0.1,\n    n_iter_no_change=20,\n    random_state=42,\n    verbose=0\n)\nnn.fit(X_train, y_train)\nnn_val_score = nn.score(X_val, y_val)\nnn_train_score = nn.score(X_train, y_train)\nprint(f\" OK Train: {nn_train_score:.2%}, Val: {nn_val_score:.2%}\")\n\n# ============================================================================\n# STEP 6: 集成預測\n# ============================================================================\nprint(\"\\n[6/8] Evaluating on test set...\")\n\nmodels = [('RF', rf), ('GB', gb), ('NN', nn)]\nproba_list = []\n\nfor name, m in models:\n    try:\n        if hasattr(m, 'predict_proba'):\n            proba = m.predict_proba(X_test)\n        else:\n            preds = m.predict(X_test)\n            proba = np.eye(5)[preds]\n        \n        if proba.shape[1] < 5:\n            padded = np.zeros((proba.shape[0], 5))\n            padded[:, :proba.shape[1]] = proba\n            padded = padded / padded.sum(axis=1, keepdims=True)\n            proba = padded\n        elif proba.shape[1] > 5:\n            proba = proba[:, :5]\n        \n        proba_list.append(proba)\n    except Exception as e:\n        proba = np.ones((len(X_test), 5)) / 5\n        proba_list.append(proba)\n\navg_proba = np.mean(proba_list, axis=0)\nensemble_pred = np.argmax(avg_proba, axis=1)\nensemble_conf = np.max(avg_proba, axis=1)\n\ntest_accuracy = accuracy_score(y_test, ensemble_pred)\navg_confidence = ensemble_conf.mean()\n\nprint(f\"\\n{'='*80}\")\nprint(\"RESULTS - TradingView ZigZag Logic\")\nprint(f\"{'='*80}\")\nprint(f\"\\nValidation Scores:\")\nprint(f\"  Random Forest:       {rf_val_score:.2%}\")\nprint(f\"  Gradient Boosting:   {gb_val_score:.2%}\")\nprint(f\"  Neural Network:      {nn_val_score:.2%}\")\nprint(f\"\\nTest Results:\")\nprint(f\"  Ensemble Accuracy:   {test_accuracy:.2%}\")\nprint(f\"  Average Confidence:  {avg_confidence:.2%}\")\n\nprint(f\"\\nClassification Report (Test Set):\")\nprint(classification_report(y_test, ensemble_pred, target_names=LABEL_NAMES, zero_division=0))\n\ncm = confusion_matrix(y_test, ensemble_pred, labels=list(range(5)))\nprint(f\"\\nConfusion Matrix:\")\nprint(cm)\n\n# ============================================================================\n# STEP 7: 特徵重要性\n# ============================================================================\nprint(\"\\n[7/8] Feature Importance Analysis...\")\nprint(f\"\\n  Top 10 Important Features (Random Forest):\")\nrf_importance = pd.DataFrame({\n    'Feature': FEATURE_NAMES,\n    'Importance': rf.feature_importances_\n}).sort_values('Importance', ascending=False)\n\nfor idx, row in rf_importance.head(10).iterrows():\n    print(f\"    {row['Feature']:20s}: {row['Importance']:.4f}\")\n\n# ============================================================================\n# STEP 8: 可視化\n# ============================================================================\nprint(\"\\n[8/8] Creating visualizations...\")\n\nfig, axes = plt.subplots(1, 2, figsize=(16, 6))\n\nsns.heatmap(\n    cm, annot=True, fmt='d', cmap='Blues', ax=axes[0],\n    xticklabels=LABEL_NAMES, yticklabels=LABEL_NAMES,\n    cbar_kws={'label': 'Count'}\n)\naxes[0].set_title('Confusion Matrix - TradingView ZigZag', fontsize=14, fontweight='bold')\naxes[0].set_ylabel('True Label')\naxes[0].set_xlabel('Predicted Label')\n\nclass_acc = []\nfor i in range(5):\n    mask = y_test == i\n    if mask.sum() > 0:\n        class_acc.append(accuracy_score(y_test[mask], ensemble_pred[mask]))\n    else:\n        class_acc.append(0)\n\nbars = axes[1].bar(\n    LABEL_NAMES, class_acc,\n    color=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']\n)\naxes[1].set_title('Per-Class Accuracy on Test Set', fontsize=14, fontweight='bold')\naxes[1].set_ylabel('Accuracy')\naxes[1].set_ylim([0, 1.05])\naxes[1].axhline(\n    y=test_accuracy, color='red', linestyle='--', linewidth=2,\n    label=f'Overall: {test_accuracy:.2%}'\n)\naxes[1].legend()\n\nfor bar, acc in zip(bars, class_acc):\n    height = bar.get_height()\n    axes[1].text(\n        bar.get_x() + bar.get_width()/2., height + 0.02,\n        f'{acc:.1%}', ha='center', va='bottom',\n        fontsize=10, fontweight='bold'\n    )\n\nplt.tight_layout()\nplt.show()\n\nprint(f\"\\n{'='*80}\")\nprint(f\"Training Complete!\")\nprint(f\"  Model: TradingView ZigZag Logic\")\nprint(f\"  Final Test Accuracy: {test_accuracy:.2%}\")\nprint(f\"  Average Confidence: {avg_confidence:.2%}\")\nprint(f\"{'='*80}\")\n\nprint(\"\\nNext Steps:\")\nprint(\"  1. Compare with old labels: how much changed?\")\nprint(\"  2. Accuracy should be significantly higher (from 20% → 65-75%)\")\nprint(\"  3. Ready to save models and upload to Hugging Face!\")\n